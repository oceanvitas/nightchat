{
  "name": "tiny",
  "description": "an in-process database",
  "author": {
    "name": "Christopher Jeffrey"
  },
  "version": "0.0.8",
  "main": "./lib/tiny.js",
  "bin": {
    "tiny": "./bin/tiny"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/chjj/node-tiny.git"
  },
  "keywords": [
    "database",
    "nosql",
    "in-process"
  ],
  "readme": "# node-tiny\n\n__node-tiny__ is an in-process document/object store for node.js.\n\nIt is largely inspired by [nStore](https://github.com/creationix/nstore), \nhowever, its goal was to implement real querying which goes easy on the memory. \n\nTiny is very simple, there are no schemas, just store your objects. It supports \nmongo-style querying, or alternatively a \"mapreduce-like\" interface similar to \nCouchDB's views.\n\n## Install\n\n``` bash\n$ npm install tiny\n```\n\n## How Tiny works...\n\nTiny takes advantage of the fact that, normally, when you query for \nrecords in a database, you're only comparing small properties (<128b) in the \nquery itself. For example, when you query for articles on a weblog, you'll \nusually only be comparing the timestamp of the article, the title, the author, \nthe category, the tags, etc. - pretty much everything except the content of \nthe article itself.\n\nTiny stores each document/object's property individually in the DB file and \ncaches all the small properties into memory when the DB loads, leaving anything \nabove 128b behind. When a query is performed, Tiny only lets you compare the \nproperties stored in memory, which is what you were going to do anyway. Once \nthe query is complete, Tiny will perform lookups on the FD to grab the large \nproperties and put them in their respective objects before results are returned \nto you.\n\nThis my attempt at combining what I think the best aspects of nStore and \nnode-dirty are. node-dirty is incredibly fast and simple (everything is \nin-memory), and nStore is very memory effecient, (but this only lasts until you \nperform a query). node-tiny allows for queries that perform lookups on the db \nfile, and it selectively caches properties as well, so its fast and easy on \nmemory.\n\nThe benefits you receive from using node-tiny depend on the kind of data you're \nworking with. With the blog example mentioned above, if you consider that the \nmetadata for a blog post may be as little as 200 bytes, a __half-million__ \narticles would use less than 100mb of memory. \n\n## Example Querying\n\n``` js\nvar Tiny = require('./tiny');\nTiny('articles.tiny', function(err, db) {\n  var time = Date.now()\n    , low = time - (60*60*1000)\n    , high = time - (30*60*1000);\n\n  // mongo-style query\n  db.find({$or: [ \n    { timestamp: { $lte: low } }, \n    { timestamp: { $gte: high } }  \n  ]})\n  .desc('timestamp')\n  .limit(3)(function(err, results) {\n    console.log('Results:', results);\n  });\n\n  // is equivalent to...\n  db.fetch({\n    desc: 'timestamp',\n    limit: 3\n  }, function(doc, key) {\n    if (doc.timestamp <= low \n        || doc.timestamp >= high) {\n      console.log('Found:', key); \n      return true;\n    }\n  }, function(err, results) {\n    console.log('Results:', results);\n  });\n});\n```\n\nThe mongo-style querying should be fairly self-explanatory. The second query is \nsupposed to be similar to a mapreduce interface, but it's the rough equivalent \nof a `.filter` function.\n\nNote: there is a `shallow` parameter for `.fetch`, `.find`, and `.get`, wherein \nit will __only__ lookup properties that are under 128b in size. This is to go \neasy on the memory. `.each` and `.all` are shallow by default, but they do have \na `deep` parameter, (which I don't recommend using).\n\n## Other Usage\n\n``` js\n// save a document\ndb.set('myDocument', {\n  title: 'a document',\n  content: 'hello world'\n}, function(err) {\n  console.log('set!');\n});\n\n// .each will iterate through\n// every object in the database\n// it is shallow by default\ndb.each(function(doc) { \n  console.log(doc.title);\n});\n\n// returns every object in the DB\n// in an array, this is shallow\n// by default\ndb.all(function(err, docs) {\n  console.log(docs.length);\n});\n\n// remove a doc\ndb.remove('myDocument', function(err) {\n  console.log('deleted');\n}); \n\n// retrieve an object from the database\ndb.get('someOtherThing', function(err, data) {\n  // data._key is a property which \n  // holds the key of every object\n  console.log('found:', data._key); \n});\n\n// updates the object \n// without overwriting its other properties\ndb.update('article_1', { \n  title: 'new title'\n}, function(err) {\n  console.log('done');\n});\n\n// close the file descriptor\ndb.close(function(err) {\n  console.log('db closed');\n});\n\n// clean up the mess\ndb.compact(function(err) {\n  console.log('done');\n});\n\n// dump the entire database to a JSON file\n// in the same directory as the DB file\n// (with an optional pretty-print parameter)\ndb.dump(true, function(err) {\n  console.log('dump complete');\n});\n```\n\n## Making data more memory efficient\n\nBecause of the way Tiny works, there are ways to alter your data to make it more \nmemory efficient. For example, if you have several properties on your objects \nthat aren't necessary to for queries, its best to nest them in an object.\n\n``` js\nuser: {\n  name: 'joe',\n  prop1: 'data',\n  prop2: 'data',\n  prop3: 'data'\n}\n\nuser: {\n  name: 'joe',\n  data: {\n    prop1: 'data',\n    prop2: 'data',\n    prop3: 'data'\n  }\n}\n```\n\nThat way, the data will not be cached if it exceeds 128b collectively. Eventually \nthere may be an `ignore` method or an `index` method, which will be explicitly \ninclusive or exclusive to which properties are cached and which properties are \nable to be referenced within a query.\n\n## Documentation\n### Database\n* [Construction](#construction)\n* [dump](#dump)\n* [close](#close)\n* [kill](#kill)\n\n### Querying\n* [set](#set)\n* [each](#each)\n* [all](#all)\n\n## Database\n<a name=\"construction\" />\n### Tiny(name, callback)\nCreates and returns a database with the given name.\n\n__Arguments__\n\n* name - filename to store and load the Tiny database\n* callback(err, db) - Called after the database file is opened and loaded\n\n__Example__\n\n``` js\nvar tinydb;\nTiny('articles.tiny', function(err, db) {\n  tinydb = db;\n  ...\n});\n```\n\n---------------------------------------\n\n<a name=\"dump\" />\n### dump(pretty, func) or dump(func)\nDumps the a database to a JSON file with the name as name.json. Pretty specifies whether to indent each line with two spaces or not. Alternatively, dump(func) can be called.\n\n__Arguments__\n\n* pretty - if true, the JSON file will be indented with two spaces\n* func(err) - called after the dump is complete.\n\n__Example__\n\n``` js\ndb.dump(true, function(err) {\n  console.log('dump complete');\n});\n```\n\n---------------------------------------\n\n<a name=\"close\" />\n### close(func)\nCloses the Tiny database file handle. A new Tiny object must be made to reopen the file.\n\n__Arguments__\n\n* func() - callback function after the database has been closed\n\n__Example__\n\n``` js\ndb.close(function(err) {\n  console.log('db closed');\n});\n```\n\n---------------------------------------\n\n<a name=\"kill\" />\n### kill(func)\nCloses the Tiny database file, deletes the file and all the data in the database, and then creates a new database with the same name and file.\n\n__Arguments__\n\n* func() - callback function after the database has been reloaded\n\n__Example__\n\n``` js\ndb.kill(function(err) {\n  console.log('db has been destroyed and a new db has been loaded');\n});\n```\n\n## Querying\n<a name=\"set\" />\n### set(docKey, doc, func)\nSaves a object `doc` to database under the key `docKey`. Ideally, docKey should be 128b or smaller.\n\n__Arguments__\n\n* docKey - a key to search the database for\n* doc - an object to save to the database under the given key\n* func - callback function after the doc object has been saved to the database\n\n__Example__\n\n``` js\ndb.set('myDocument', {\n  title: 'a document',\n  content: 'hello world'\n}, function(err) {\n  console.log('set!');\n});\n```\n\n---------------------------------------\n\n<a name=\"each\" />\n### each(func, deep) or each(func)\nIterates through every object in the database.\n\n__Arguments__\n\n* func(doc) - Callback function that is called with every iterated object `doc` from the database\n* done() - Callback to be executed after the iterations complete.\n* deep - `true` if every object should be returned, `false` or unset if only cacheable objects should be returned (ones smaller than 128b)\n\n__Example__\n\n``` js\ndb.each(function(doc) {\n  console.log(doc.title);\n}, function() {\n  console.log('done');\n});\n```\n\n---------------------------------------\n\n<a name=\"all\" />\n### all(func, deep) or all(func)\nReturns an array containing all the objects in the database. By default, it will only return cacheable objects (ones smaller than 128b).\n\n__Arguments__\n\n* func(err, docs) - Callback function called with `docs`, the entire array of objects from the database\n* deep - `true` if every object should be returned, `false` or unset if only cacheable objects should be returned (ones smaller than 128b)\n\n__Example__\n\n``` js\ndb.all(function(err, docs) {\n  console.log(docs.length);\n});\n```\n\n## License\n\nSee LICENSE (MIT).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chjj/node-tiny/issues"
  },
  "_id": "tiny@0.0.8",
  "_from": "tiny@"
}
